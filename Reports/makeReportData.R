#' @title Extract WHAM results for report
#' @description Pull WHAM results from the current MT model, projections, and the prior MT assessment, format, and save as an .RDS object for use in generating short reports.
#' 
#' @param model_MT The current fitted WHAM assessment model object, no default.
#' @param model_MTproj The current fitted WHAM assessment with projections implemented, no default.
#' @param model_prior The prior assessment model provided as a WHAM model object 
#' @param multiWHAM A vector of booleans for 1) the current MT model and 2) the current MT model with projections applied and 3) the prior assessment, if TRUE, assumes that the model is generated by multi-WHAM and includes additional indexing for region/stock as well as any differences in labels. Default = FALSE.
#' @param index_names A vector of index names (with NO spaces) that match the order they are listed in the model_MT, default = "index1", "index2"..."index_n". Also used in automatically labeling indices in report unless column names manually overwritten in MT report template. Using spaces or special characters (like "&") in index_names will result in nasty LaTex errors.
#' @param outdir A file path specifying the directory where MT report data should be saved
#' 
#' @return A list containing the following and saved as an RDS object named "reportData", also saves CSV files with model results and index time series:
#' \itemize{
#'   \item{comb.model.summary - A table containing SSB, F, and Recruitment estimates with CVs for the current MT and prior assessments}
#'   \item{text_msy - Text for MSY proxy BRP}
#'   \item{text_ssb - Text for SSB proxy BRP}
#'   \item{text_f - Text for F proxy BRP}
#'   \item{proj_yrs - Projection years, pulled from model_MTproj}
#'   \item{MT_BRPs - A table of MT BRPs with 95\% CI}
#'   \item{indices - A table of index time series with associated CVs}
#'   \item{n_indices - The number of indices in model_MT}
#'   \item{MT_termyr - A table of estimates and rho-adjusted values for F, SSB, and Recruitment terminal year estimates, associated CVs and the BRP ratio}
#' }   

library(tidyverse)
library(wham)
library(DataExplorer)
# source(here::here("Reports/pullResults_WHAM.R"))
# source(here::here("Reports/calc.rho.adj.ests.R"))
# source(here::here("Reports/calc.uncertainty.R"))

makeReportData <- function(model_MT = NULL,
                           model_MTproj = NULL,
                           model_prior = NULL,
                           multiWHAM = c(FALSE, FALSE, FALSE),
                           index_names = NULL,
                           outdir = FALSE){
  
  
  
  
  # Storage for returned list #####
  return_list <- NULL
  
  
  # Pull MT model estimates #####
  MT_results <- pullResults_WHAM(model = model_MT, multiWHAM = multiWHAM[1])
  return_list$MT_BRPs <- MT_results$brps
  return_list$MT_MohnsRho <- MT_results$Mohns_rho
  return_list$MT_termyr <- MT_results$termyr.ests.cis
  
  # Check if retro is significant (TRUE if rho-adjusted F or SSB in terminal year falls outside 90% CI for model estimate)
  check_SSBadj <- MT_results$SSB.yr_adj %>% group_by(YEAR) %>% mutate(doAdj_SSB = (est.adj <= hi_90 & est.adj >= lo_90) == FALSE) %>% tail(n=1) %>% select(doAdj_SSB)
  check_Fadj <- MT_results$F.yr_adj %>% group_by(YEAR) %>% mutate(doAdj_F = (est.adj <= hi_90 & est.adj >= lo_90) == FALSE) %>% tail(n=1) %>% select(doAdj_F)
  return_list$MT_retro.signif <- TRUE %in% full_join(check_SSBadj, check_Fadj) # Returns FALSE if no SSB or F adjustment needed and TRUE if either require an adjustment
  
  # # Check stock status !!! Check this, I think that SSB_status should be 0.5*SSBproxy, may want to build in the option here to provide the target/threshold/ect. to use in determining stock status & feed into MT report
  # F_status <- MT_results$termyr.ests.cis[which(MT_results$termyr.ests.cis$Parameter == "F"),"est"] > MT_results$brps[which(MT_results$brps$BRP == "Fproxy"),"est"] %>% unlist()
  # SSB_status <- MT_results$termyr.ests.cis[which(MT_results$termyr.ests.cis$Parameter == "SSB"),"est"] < MT_results$brps[which(MT_results$brps$BRP == "SSBproxy"),"est"] %>% unlist()
  
  # Pull out index time series with CVs
  indices <- cbind(model_MT$input$data$agg_indices, model_MT$input$data$agg_index_sigma) %>% as.data.frame() %>% mutate(Year = model_MT$years)
  if(is.null(index_names) == TRUE){
    index_names = paste0("index", 1:model_MT$input$data$n_indices)
  }
  colnames(indices) <- c(index_names, paste0(index_names,"_CV"), "Year")
  indices <- as.matrix(indices)
  indices[which(indices == -999)] <- NA # Replace -999 placeholders with NAs
  
  return_list$indices <- indices %>% as.data.frame()
  return_list$n_indices <- model_MT$input$data$n_indices
  
  # MT_est <- as.list(model_MT$sdrep, what = "Est", report = TRUE)
  # MT_sd <- as.list(model_MT$sdrep, what = "Std", report = TRUE)
  # 
  # # Reference points
  # MT_Fproxy <- MT_est$log_FXSPR_static %>% exp() %>% c(est = ., lo = NA, hi = NA) 
  # 
  # MT_SSBproxy <- data.frame(logSSBproxy = MT_est$log_SSB_FXSPR_static, logSSBproxy_sd = MT_sd$log_SSB_FXSPR_static) %>%
  #   mutate(est = exp(logSSBproxy),
  #          lo = exp(logSSBproxy - qnorm(0.975)*logSSBproxy_sd),
  #          hi = exp(logSSBproxy + qnorm(0.975)*logSSBproxy_sd))
  # 
  # MT_MSYproxy <- data.frame(logMSYproxy = MT_est$log_Y_FXSPR_static, logMSYproxy_sd = MT_sd$log_Y_FXSPR_static) %>%
  #   mutate(est = exp(logMSYproxy),
  #          lo = exp(logMSYproxy - qnorm(0.975)*logMSYproxy_sd),
  #          hi = exp(logMSYproxy + qnorm(0.975)*logMSYproxy_sd))
  # 
  # brps <- bind_rows('Fproxy' = MT_Fproxy, 'SSBproxy' = MT_SSBproxy, 'MSYproxy' = MT_MSYproxy, .id="BRP") %>% select(BRP, est, lo, hi)
  # 
  # # At-age information
  # if(multiWHAM = TRUE){
  #   NAA <- cbind(YEAR = model_MT$years, model_MT$rep$NAA[1,,,]) # Should check that this works for BSB since this additional indexing present in multi-wham only
  #   colnames(NAA) <- c("YEAR", paste0("AGE", model_MT$ages.lab))
  # } else{
  #   NAA <- cbind(YEAR = model_MT$years, model_MT$rep$NAA)
  #   colnames(NAA) <- c("YEAR", paste0("AGE", model_MT$ages.lab))
  # }
  # 
  # 
  # FAA <- cbind(YEAR = model_MT$years, model_MT$rep$FAA_tot)
  # colnames(FAA) <- c("YEAR", paste0("AGE", model_MT$ages.lab))
  # 
  # # Mohn's rho
  # Mohns_rho <- mohns_rho(model_MT)
  # names(Mohns_rho)[names(Mohns_rho)=='Fbar'] <- 'F'
  # names(Mohns_rho)[names(Mohns_rho)=='R'] <- 'Rect'
  # 
  # 
  # # Annual F
  # F.yr <- calc.uncertainty(log.est = MT_est$log_F, log.se = MT_sd$log_F) %>% mutate(YEAR = model_MT$years, .before = "est") %>%
  #   mutate(relF = est/MT_Fproxy["est"]) %>%
  #   calc.rho.adj.ests(., rho = Mohns_rho$F) %>%
  #   mutate(relF.adj = est.adj/Fproxy)
  # 
  # return_list$F.yr <- F.yr %>% select(Year = YEAR, F = est, F.CV = CV)
  # 
  # # Annual SSB
  # SSB.yr <- calc.uncertainty(log.est = MT_est$log_SSB, log.se = MT_sd$log_SSB) %>% mutate(YEAR = model_MT$years, .before = "est") %>%
  #   mutate(relSSB = est/MT_SSBproxy$est) %>% #!!! confirm this is working as desired
  #   calc.rho.adj.ests(., rho = Mohns_rho$SSB) %>% 
  #   mutate(relSSB.adj= est.adj/MT_SSBproxy$est)
  # 
  # return_list$SSB.yr <- SSB.yr %>% select(Year = YEAR, SSB = est, SSB.CV = CV)
  # 
  # # Recruitment
  # Rect.yr <- calc.uncertainty(log.est = MT_est$log_NAA_rep[,1], log.se = MT_sd$log_NAA_rep[,1]) %>% mutate(YEAR = model_MT$years, .before = "est") %>%
  #   calc.rho.adj.ests(., rho = Mohns_rho$naa[1]) # !!! confirm naa indexing for mohn's rho works across single and multi-wham options
  # 
  # return_list$Rect.yr <- Rect.yr %>% select(Year = YEAR, Rect = est, Rect.CV = CV)
  # 
  # 
  # # Condense terminal year estimates with CIs
  # model.lyr = tail(model_MT$years, n=1)
  # termyr.ests.cis <- bind_rows(
  #   F = filter(F.yr, YEAR == model.lyr) %>% rename(BRP.ratio = relF, BRP.ratio.adj = relF.adj),
  #   SSB = filter(SSB.yr, YEAR == model.lyr) %>% rename(BRP.ratio = relSSB, BRP.ratio.adj = relSSB.adj),
  #   .id = "Parameter") %>%
  #   bind_rows(., filter(Rect.yr, YEAR == model.lyr) %>% mutate(Parameter = "Rect")) %>%
  #   select(Parameter, est, CV, lo, hi, BRP.ratio, est.adj, lo.adj, hi.adj, BRP.ratio.adj) 
  # 
  # #!!! write CSV files line 154 of Analyze.WHAM_basic.Outputs.R ??? see if this is necessary or if can just proceed to next step
  
  
  # MT projections #####
  if(multiWHAM[2] == TRUE){ # If using multi-wham model
    sdrep <- summary(model_MTproj$sdrep) %>% as.data.frame()
  } else if(devtools::package_info() %>% as.data.frame() %>% filter(package == "wham") %>% select(date) %>% as.Date.character() %>% difftime(., "2024-04-30") <= 0 ) { # If single-wham version installed before April 30, 2024 change method to summarize sdrep (arbitrary date based on testing by cod leads)
    sdrep <- as.data.frame(model_MTproj$sdrep) 
  } else { # If single-wham version installed after April 30, 2024 use same summary method as multi-wham
    sdrep <- summary(model_MTproj$sdrep) %>% as.data.frame()
  } 

  proj.yrs = model_MTproj$input$years_full[which(! model_MTproj$input$years_full %in% model_MTproj$input$years)]
  return_list$proj_yrs = proj.yrs
  
  # Catch: observed & projected years !!! has issues, "log_catch_proj doesn't exist in multi-wham sdrep
  if(multiWHAM[2] == TRUE){
    catch_proj <- model_MTproj$rep$pred_catch %>% as.data.frame() %>% 
      mutate(YEAR = model_MTproj$input$years_full, est = V1, lo_95 = NA, hi_95 = NA) %>% # Placeholders for lo/hi 95% CI since catch not reported with se in multi-wham !!! V1 is the first column for a single-area model, expect multiple columns in multi-WHAM with several areas
      drop_columns("V1") %>%
      filter(YEAR %in% proj.yrs) 
    catch_obs <- model_MTproj$input$data$agg_catch %>% as.data.frame() %>% mutate(YEAR = model_MTproj$input$years, est = V1) %>% drop_columns("V1") 
    catch_allyrs <- bind_rows(catch_obs, catch_proj) # Add catch projections to observed catch series
    
  } else{ # Single-wham
    catch_proj <- sdrep[grep("log_catch_proj", rownames(sdrep), fixed = TRUE),] #%>% exp() #!!! need to test
    catch_proj <- calc.uncertainty(log.est = catch_proj$Estimate, log.se = catch_proj$`Std. Error`) %>% drop_columns("CV") %>% 
      mutate(YEAR = proj.yrs) %>% filter(YEAR %in% proj.yrs)
    #mutate(YEAR = model_MTproj$input$years_full) %>% filter(YEAR %in% proj.yrs)
    
    catch_obs <- model_MTproj$input$data$agg_catch %>% as.data.frame() %>% mutate(YEAR = model_MTproj$input$years, est = V1) %>% drop_columns("V1") 
    catch_allyrs <- bind_rows(catch_obs, catch_proj) %>% drop_columns("se") # Add catch projections to observed catch series
  }
  return_list$proj_catch <- catch_allyrs %>% filter(YEAR %in% proj.yrs) %>% drop_columns(c("YEAR")) %>% round(.,0) #!!! test
  
  
  # SSB: model & projected years
  if(multiWHAM[2] == TRUE){ # Pull log_SSB_all
    ssb_proj <- sdrep[grep("log_SSB_all", rownames(sdrep), fixed = TRUE),] 
    ssb_allyrs <- calc.uncertainty(log.est = ssb_proj$Estimate, log.se = ssb_proj$`Std. Error`) %>% drop_columns("CV") %>% mutate(YEAR = model_MTproj$years_full)
  } else{ # pull log_SSB
    ssb_proj <- sdrep[grep("log_SSB", rownames(sdrep), fixed = TRUE),] 
    ssb_proj <- ssb_proj[!grepl("FXSPR", rownames(ssb_proj), fixed=TRUE),]
    ssb_allyrs <- calc.uncertainty(log.est = ssb_proj$Estimate, log.se = ssb_proj$`Std. Error`) %>% drop_columns("CV") %>% mutate(YEAR = model_MTproj$years_full)
  }
  return_list$proj_ssb <- ssb_allyrs %>% filter(YEAR %in% proj.yrs) %>% round(., 0) %>% drop_columns(c("se", "YEAR"))
  
  # Generate SSB projection text
  return_list$text_ssb.proj <-  apply(return_list$proj_ssb, 1, function(x) {
    paste(x['est'], " (", x['lo_95'], " - ", x['hi_95'], ")", sep="")
  })
  
  
  # Max F: model & projected years
  FAA.allyrs <- sdrep[grep("log_FAA_tot", rownames(sdrep), fixed = TRUE),]
  FAA.allyrs <- calc.uncertainty(log.est=FAA.allyrs$Estimate, log.se=FAA.allyrs$`Std. Error`) %>% drop_columns("CV") %>% # Calculate CIs for FAA estimates
    mutate(AGE = rep(1:model_MTproj$input$data$n_ages, each=length(model_MTproj$years_full)),YEAR = rep(c(model_MTproj$years_full), model_MTproj$input$data$n_ages))
  
  return_list$proj_F <- FAA.allyrs %>% 
    filter(AGE == model_MTproj$input$data$n_ages) %>% # Select projected F for maximum age
    filter(YEAR %in% proj.yrs) %>% 
    drop_columns(c("se", "YEAR", "AGE")) %>% 
    round(.,3) 
  
  # #Check confirms that sdrep lists by age and year
  # calc.uncertainty(log.est=FAA.allyrs$Estimate, log.se=FAA.allyrs$`Std. Error`) %>% drop_columns("CV") %>% mutate(AGE = rep(1:model_MTproj$input$data$n_ages, each=length(model_MTproj$years_full))) %>% filter(AGE==2) %>% select(est) %>% cbind(model_MTproj$rep$FAA[1,,2])
  
  # NAA: model & projected years
  # NAA for year 2-end
  if (multiWHAM[2] == TRUE) {
    NAA <- sdrep[grepl("log_NAA", rownames(sdrep), fixed = TRUE)==TRUE & grepl("log_NAA_rep", rownames(sdrep), fixed = TRUE)==FALSE & grepl("log_NAA_sigma", rownames(sdrep), fixed = TRUE)==FALSE,]
    mutate(AGE = rep(1:model_MTproj$input$data$n_ages, each=length(model_MTproj$years_full)-1))
  } else {
    NAA <- sdrep[grepl("log_NAA_rep", rownames(sdrep), fixed = TRUE),]
    NAA <- calc.uncertainty(log.est=NAA$Estimate, log.se=NAA$`Std. Error`) %>% drop_columns("CV") %>% # Calculate CIs for NAA estimates
      mutate(AGE = rep(1:model_MTproj$input$data$n_ages, each=length(model_MTproj$years_full)))
  }
  
  # NAA for year 1
  N1_param <- sdrep[grep("log_N1", rownames(sdrep), fixed = TRUE),] # Will work for single and multi-wham
  if(nrow(N1_param) == model_MTproj$input$data$n_ages){
    N1 <- calc.uncertainty(log.est=N1_param$Estimate, log.se=N1_param$`Std. Error`) %>% drop_columns("CV") %>% # Calculate CIs for NAA estimates
      mutate(AGE = 1:model_MTproj$input$data$n_ages)
  } else{ # If NAA in year 1 not estimated by age, pull values from rep without parameter CI
    if (multiWHAM[2] == TRUE) {N1 <- model_MTproj$rep$NAA[1,,1,]} else {N1 <- model_MTproj$rep$NAA[1,]}
  }
  # Recruitment in all years
  if (multiWHAM[2] == TRUE) {
    Rect.allyrs <- NAA %>% filter(AGE == 1) %>% rbind(c(N1[1], NA, NA, NA, 1),.) %>% mutate(YEAR = model_MTproj$years_full)
  } else {
    Rect.allyrs <- NAA %>% filter(AGE == 1) %>% mutate(YEAR = model_MTproj$years_full)
  }
  return_list$proj_Rect <- Rect.allyrs %>% filter(YEAR %in% proj.yrs) %>% drop_columns(c("se", "YEAR", "AGE")) %>% round(.,0)
  
  #!!! Save all of the above in proj.summary and in the Projection.summary.csv
  
  
  
  # Pull prior assessment model estimates #####
  if("wham_version" %in% rownames(summary(model_prior)) == TRUE){ # If prior assessment is a WHAM model then extract results
    prior_results <- pullResults_WHAM(model_prior, multiWHAM = multiWHAM[3])
    return_list$prior_BRPs <- prior_results$brps
    return_list$prior_MohnsRho <- prior_results$Mohns_rho
  } else{ # Otherwise pull results from model_prior list
    warning("Have not built out options to format prior assessment results if not a WHAM model")
  }
  
  # Check if retro is significant (TRUE if rho-adjusted F or SSB in terminal year falls outside 95% CI for model estimate)
  check_SSBadj <- prior_results$SSB.yr_adj %>% group_by(YEAR) %>% mutate(doAdj_SSB = (est.adj <= hi_90 & est.adj >= lo_90) == FALSE) %>% tail(n=1) %>% select(doAdj_SSB)
  check_Fadj <- prior_results$F.yr_adj %>% group_by(YEAR) %>% mutate(doAdj_F = (est.adj <= hi_90 & est.adj >= lo_90) == FALSE) %>% tail(n=1) %>% select(doAdj_F)
  return_list$prior_retro.signif <- TRUE %in% full_join(check_SSBadj, check_Fadj) # Returns FALSE if no SSB or F adjustment needed and TRUE if either require an adjustment
  
  
  
  # Finish text and results formatting #####
  MT_BRP <- MT_results$brps %>% mutate(source = "MT")
  BRPs <- prior_results$brps %>% mutate(source = "prior") %>% full_join(., MT_BRP) # Combine prior & MT BRPs
  
  # Generate text for MSY, SSB and F proxies (BRPs)
  return_list$text_msy <- create.brp.text(brp.name = 'MSYproxy', round.digits = 0, brp.table = BRPs)
  return_list$text_ssb <- create.brp.text(brp.name = 'SSBproxy', round.digits = 0, brp.table = BRPs)
  return_list$text_f <- create.brp.text(brp.name = 'Fproxy', round.digits = 2, brp.table = BRPs)
  
  
  # Create model results tables #####
  model.summary <- full_join(MT_results$SSB.yr, MT_results$F.yr) %>% 
    full_join(., MT_results$Rect.yr)
  
  prev.model.summary <- full_join(prior_results$SSB.yr, prior_results$F.yr) %>%
    full_join(., prior_results$Rect.yr)
  colnames(prev.model.summary) <- c("Year", paste0("prev_",colnames(prev.model.summary)[-1]))
  
  comb.model.summary <- full_join(model.summary, prev.model.summary)
  
  whole.cols <- c("Year", "SSB","Rect","prev_SSB","prev_Rect") # Round numbers for output
  dec.cols <- colnames(comb.model.summary)[!colnames(comb.model.summary) %in% whole.cols]
  
  return_list$model_results <- comb.model.summary %>%
    mutate(across(all_of(whole.cols), round, 0)) %>%
    mutate(across(all_of(dec.cols), round, 3)) 
  
  
  # Save and return #####
  saveRDS(return_list, file = paste0(outdir, "/reportData.RDS")) # Save reportData as .RDS file
  write.csv(return_list$model_results, file = paste0(outdir, "/model_results.csv")) # Write SSB/F/R to .CSV
  write.csv(return_list$indices, file = paste0(outdir, "/survey_results.csv")) # Write index time series to .CSV
  
  return(return_list)
}


